---
title: "Closed-Source Deliveries with Go Plugins"
date: 2025-09-29
layout: single
---

Let's say your customer wants a partial closed source delivery. Source in one internal repository, API definition, shared object, and loader in another for a customer - just like C++! Go is, like, C++ plusplus so it should work too, right?

Ehhhh, yes... but not without effort to figure out how. Hopefully, this post about how I set up this split delivery saves you some time and effort if you need to follow the same trimmed path.

---

## The Split-Brain Repo Model

- **Source repository** - the actual plugin code. This never leaves the building. We'll call it `banana`.  
- **Delivery repository** - the API definition, a loader, and the compiled `.so` file. This is what the customer sees. It's called `banana-sdk`.

HashiCorp's `go-plugin` was tempting, but after consideration we didn't go for it. Not because it doesn't work, but because it brings both runtime overhead and cognitive complexity overhead. Supervisors, RPC schemas, process management, cross-process debugging. The future maintenance tax was obvious.

Instead, we chose the standard library's `plugin` package. It's lean, native, and got the job done (eventually). But you have to be willing to do the initial coding with a minesweeper and extreme patience.

---

## What Is a Go Plugin?

Go plugins are shared libraries (`.so`) you can load at runtime, compiled using `go build -buildmode=plugin`. Call `plugin.Open()`, `Lookup()` an exported symbol, type assert it, and there you go.

Congratulations, you now know more about Go plugins than the official language maintainers.

Unlike languages with robust reflection systems, Go doesn't give you a handy manifest of what's inside. Without an API contract, our customer would have no idea what's inside. Unless they wanted to do a ton of `Lookup()` calls. That's why we provide a separate API definition package in the delivery repo. That way, our customers know what exists in the SDK for them to use.

---

## Where It All Breaks

On first blush, building looks straightforward:

1. Compile `.so` in source repo (referring to the API in the delivery repo).  
2. Drop `.so` into the delivery repo.  
3. Tag and ship.  

I tried this out. It blew up in my face. This is where the patience comes in.

After my mentor and I spent a grueling amount of time staring at the problem, my wonderful mentor used his embedded software wizardry to find the undocumented mine: **package identity checksums**.

When you compile a Go plugin, it embeds metadata about every package it imports: Exact versions, build tags, and toolchain. If the host binary was built with any difference, Go refuses to load the plugin. At runtime, Go panics with:

```text
plugin was built with a different version of package runtime
```

---

## Our Wonderful, Simple Build Process

To get around this, we built a fragile little dance. Let's say we're releasing `v1.2.3`:

1. Delivery repo has a template loader.  
2. Makefile fills in the version info (`v1.2.3`), commits, tags, pushes.  
3. Switch to source repo, build the `.so` against that exact tag, tag source as `v1.2.3`, push.  
4. Copy `.so` into delivery repo, commit, push.  
5. Delete the `v1.2.3` tag from delivery repo, re-tag at the commit with the plugin, push again.  

Yes, this is ridiculous. But it works!

---

### Extra Gotchas

- Life is much easier if plugin **and** consumer are both compiled with `-trimpath`. I've read it's not strictly necessary, but I've never gotten this already-fragile process to work without it.  
- If you want to run race detection, you must compile plugin and consumer with the `-race` flag. The race detector modifies concurrency packages under the hood, so they must be in lockstep.  
- `GOOS`, `GOARCH`, and Go version must be identical between plugin and consumer.  

I repeat: **this is extremely fragile.**

---

## Debugging a Bad Load

When things go wrong (and they will), here's a handy toolkit:

1. `go version -m plugin.so` - shows module metadata inside the `.so`.  
2. `go version -m host-binary` - compare against host.  
3. `GODEBUG=plugin=3 ./host` - verbose loader logs.  
4. `strings plugin.so | grep -i buildinfo` - last resort probing.  

And of course: double-check the build flags.

---

## Closing Thoughts

"Uh, this doesn't seem like a well-supported feature." Yep! Go clearly does not want you to do this. The language philosophy prefers:

- Open source delivery  
- Entire-app precompiled binaries  
- All-in-house builds  

So the partial closed-source delivery model feels bolted on because it is. It works, but only if you're willing to maintain fragile build rituals, pin toolchains, and be patient.


## Errata

We did not encounter these, but I wrote down the contents of an extremely helpful reddit comment by a current or former CircleCI employee that has since been removed. I rewrite it here for posterity:

Any packages outside of the standard library that are used by both the plugin and the program must have their versions match exactly. This means that when distributing a program binary, you must communicate the exact versions of all dependencies. Running `go version -m` causes the list of dependencies to be embedded in the binary directly. The user can get the list of dependencies by running `go version -m` on the binary delivered.

In order to work on things like Alpine Linux's musl libc6-compat, everything must be compiled for compatibility with LSB 3. Setting `_FORTIFY_SOURCE=2` with GNU libc causes the CGO 1.12 runtime to require LSB 4. Several distros (including Ubuntu 14.04, which CircleCI uses) patch their GCC to define `_FORTIFY_SOURCE=2` by default. When compiling plugins, users/customers may need to fuss with setting `CGO_CPPFLAGS` to make things not fall over.

Because plugins use the libc dynamic linker, they force `CGO_ENABLE on`; cross-compiling is no longer easy to do. Someone wanting to compile a plugin for the GNU/Linux program binary from their macOS workstation must compile the plugin in a VM (or Docker, since Docker for Mac runs in a VM).